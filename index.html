<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Gesture Christmas Tree - Three.js</title>
    <style>
        body { margin: 0; overflow: hidden; background: #050a05; font-family: 'Segoe UI', sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; }
        
        /* UI Panel */
        .ui-overlay {
            position: absolute; top: 20px; left: 20px;
            background: rgba(0, 40, 0, 0.7);
            padding: 20px; border-radius: 12px; border: 1px solid #c9a063;
            color: #c9a063; backdrop-filter: blur(10px); z-index: 10;
        }
        .control-group { margin-bottom: 15px; }
        select, input { background: #1a331a; border: 1px solid #c9a063; color: white; padding: 5px; border-radius: 4px; }
        
        /* Camera Preview */
        #video-preview {
            position: absolute; bottom: 20px; right: 20px;
            width: 240px; height: 180px; border: 2px solid #c9a063;
            border-radius: 8px; transform: scaleX(-1);
        }
        
        #fullscreen-btn {
            position: absolute; top: 20px; right: 20px;
            padding: 10px 20px; background: #c9a063; border: none;
            border-radius: 5px; cursor: pointer; font-weight: bold;
        }
    </style>
</head>
<body>

<div class="ui-overlay">
    <h3>ğŸ„ ç²’å­äº¤äº’æ§åˆ¶</h3>
    <div class="control-group">
        <label>æ¨¡å‹é€‰æ‹©: </label>
        <select id="model-select">
            <option value="tree">åœ£è¯æ ‘ (Tree)</option>
            <option value="heart">çˆ±å¿ƒ (Heart)</option>
            <option value="sphere">æ˜Ÿäº‘ (Sphere)</option>
            <option value="lotus">èŠ±æœµ (Lotus)</option>
        </select>
    </div>
    <div class="control-group">
        <label>ç²’å­é¢œè‰²: </label>
        <input type="color" id="color-picker" value="#ffcc00">
    </div>
    <div style="font-size: 12px; opacity: 0.8;">
        âœŠ æ¡æ‹³: åˆæ‹¢ | ğŸ–ï¸ å¼ å¼€: æ‰©æ•£<br>
        ğŸ”„ æ‰‹éƒ¨ç§»åŠ¨: æ—‹è½¬ç³»ç»Ÿ
    </div>
</div>

<button id="fullscreen-btn">å…¨å±æ¨¡å¼</button>
<video id="video-preview" autoplay playsinline></video>
<div id="canvas-container"></div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
/**
 * åˆ›æ„å‰ç«¯ä¸“å®¶å®ç°ï¼šæ‰‹åŠ¿äº¤äº’3Dç²’å­ç³»ç»Ÿ
 */

let scene, camera, renderer, particles, geometry;
let targetPositions = [];
const PARTICLE_COUNT = 8000;
const color = new THREE.Color("#c9a063");

// 1. åˆå§‹åŒ– Three.js åœºæ™¯
function initScene() {
    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x050a05, 0.002);

    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 5;

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    // åˆ›å»ºåˆå§‹ç²’å­
    geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(PARTICLE_COUNT * 3);
    for (let i = 0; i < PARTICLE_COUNT * 3; i++) {
        positions[i] = (Math.random() - 0.5) * 10;
    }
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

    const material = new THREE.PointsMaterial({
        size: 0.035,
        color: color,
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false
    });

    particles = new THREE.Points(geometry, material);
    scene.add(particles);

    // ç¯å…‰
    const light = new THREE.PointLight(0xffffff, 1);
    light.position.set(5, 5, 5);
    scene.add(light);
}

// 2. å½¢çŠ¶ç”Ÿæˆç®—æ³•
function generateShape(type) {
    const arr = new Float32Array(PARTICLE_COUNT * 3);
    for (let i = 0; i < PARTICLE_COUNT; i++) {
        let x, y, z;
        if (type === 'tree') {
            const h = Math.random() * 4;
            const r = (4 - h) * 0.4 * Math.random();
            const angle = Math.random() * Math.PI * 2;
            x = Math.cos(angle) * r;
            y = h - 2;
            z = Math.sin(angle) * r;
        } else if (type === 'heart') {
            const t = Math.random() * Math.PI * 2;
            x = 0.15 * (16 * Math.pow(Math.sin(t), 3));
            y = 0.15 * (13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t));
            z = (Math.random() - 0.5) * 0.5;
        } else {
            // é»˜è®¤çƒä½“
            const phi = Math.acos(-1 + (2 * i) / PARTICLE_COUNT);
            const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;
            x = Math.cos(theta) * Math.sin(phi) * 2;
            y = Math.sin(theta) * Math.sin(phi) * 2;
            z = Math.cos(phi) * 2;
        }
        arr[i * 3] = x;
        arr[i * 3 + 1] = y;
        arr[i * 3 + 2] = z;
    }
    return arr;
}

// 3. MediaPipe æ‰‹åŠ¿è¯†åˆ«é€»è¾‘
const videoElement = document.getElementById('video-preview');
const hands = new Hands({
    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
});

hands.setOptions({
    maxNumHands: 1,
    modelComplexity: 1,
    minDetectionConfidence: 0.5,
    minTrackingConfidence: 0.5
});

let scaleFactor = 1;
let targetRotation = { x: 0, y: 0 };

hands.onResults((results) => {
    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        const landmarks = results.multiHandLandmarks[0];
        
        // è®¡ç®—é£ŸæŒ‡å°–å’Œæ‹‡æŒ‡å°–è·ç¦»åˆ¤å®šå¼ åˆ
        const dx = landmarks[8].x - landmarks[4].x;
        const dy = landmarks[8].y - landmarks[4].y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        
        // æ˜ å°„ï¼šå¼ å¼€(dist > 0.15) -> æ‰©æ•£ï¼Œæ¡æ‹³(dist < 0.05) -> ç¼©æ”¾
        scaleFactor = THREE.MathUtils.lerp(scaleFactor, dist * 8, 0.1);
        
        // æ‰‹éƒ¨ä½ç½®æ§åˆ¶æ—‹è½¬
        targetRotation.y = (landmarks[9].x - 0.5) * Math.PI;
        targetRotation.x = (landmarks[9].y - 0.5) * Math.PI;
    }
});

const cameraUtils = new Camera(videoElement, {
    onFrame: async () => { await hands.send({ image: videoElement }); },
    width: 640, height: 480
});
cameraUtils.start();

// 4. åŠ¨ç”»å¾ªç¯
let currentShape = generateShape('tree');

function animate() {
    requestAnimationFrame(animate);
    
    const positions = geometry.attributes.position.array;
    for (let i = 0; i < PARTICLE_COUNT * 3; i++) {
        // å‘ç›®æ ‡å½¢çŠ¶æ’å€¼å¹¶å—æ‰‹åŠ¿ç¼©æ”¾å› å­å½±å“
        const target = currentShape[i] * scaleFactor;
        positions[i] += (target - positions[i]) * 0.1;
    }
    geometry.attributes.position.needsUpdate = true;

    particles.rotation.y += 0.002 + (targetRotation.y - particles.rotation.y) * 0.05;
    particles.rotation.x += (targetRotation.x - particles.rotation.x) * 0.05;

    renderer.render(scene, camera);
}

// 5. äº‹ä»¶ç›‘å¬
document.getElementById('model-select').addEventListener('change', (e) => {
    currentShape = generateShape(e.target.value);
});

document.getElementById('color-picker').addEventListener('input', (e) => {
    particles.material.color.set(e.target.value);
});

document.getElementById('fullscreen-btn').addEventListener('click', () => {
    if (!document.fullscreenElement) document.documentElement.requestFullscreen();
    else document.exitFullscreen();
});

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

// å¯åŠ¨
initScene();
animate();
</script>
</body>
</html>